---
title: "ValPred_Talk"
author: "Kate Saunders"
date: "12/03/2019"
output: ioslides_presentation
---

<style>
.fullslide img {
  margin-top: -85px;
  margin-left: -60px;
  width: 900px; 
  height: 700px;
}
</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library(cluster)
library(ggplot2)
library(plotly)
library(dplyr)
```

# Motivation

## Standard Approach

<br>
<br>
<br>
 In meteorology or climate, it is common to pool data or consider problems on a region by region basis. 
<br>
<br>
<br>
This can make statistical problems more tractable.

## Climate example

National Resource Management Regions
<!-- % NRM clusters -->
<!-- @book{bureau2015climate, -->
<!--   title={Climate change in Australia}, -->
<!--   author={CSIRO{\ } and {\ } Bureau{\ }of{\ }Meteorology}, -->
<!--   publisher={CSIRO and Bureau of Meteorology, Australia}, -->
<!--   year={2015} -->
<!-- } -->
<!--   title={Climate change in Australia. Information for Australiaâ€™s natural resource management regions: Technical Report}, -->

<center>
<img src= "img/NRM_sub_clusters.pdf" width = 49%>
<img src= "img/NRM_super_clusters.pdf" width = 49%>

## Post-processing example

<!-- Whan, Kirien, and Maurice Schmeits. "Comparing area probability forecasts of (extreme) local precipitation using parametric and machine learning statistical postprocessing methods." Monthly Weather Review 146.11 (2018): 3651-3673. -->

<center>
<img src= "img/aerial_post_processing.png" width = 50%>

## Question 

<br><br><br><br><br>
<font color="2292B5">**How should assign regions for the analysis of extremes?** </font> 

## Application

<font color="2292B5">**Assign regions that are likely to experience similar impacts** </font>

```{r, echo = FALSE}
wdir = paste(getwd(), "data", sep = "/")
mainland_df = readRDS(paste(wdir, "mainland_df.rds", sep =  "/"))
tas_df = readRDS(paste(wdir, "tas_df.rds", sep =  "/"))
coords = readRDS(paste(wdir, "region_coords.rds", sep = "/")) %>%
  dplyr::bind_rows()
station_plot <- ggplot(data = coords) +
  geom_point(aes(x = longitude, y = latitude), size = 0.2, alpha = 0.5) +
  geom_path(data = mainland_df, aes(x = Long, y =Lat)) +
  geom_path(data = tas_df, aes(x = Long, y =Lat)) +
  xlab("Longitude") +
  ylab("Latitude") +
  ggtitle("Station Locations") +
  coord_fixed() +
  theme_bw()
station_plot
```

## Regionalisation

<font color="2292B5">**Use these regions to inform our statistical analysis** </font>

<center>
<img src= "img/aus_regionalisation.png" width = 80%>

## Outline 

<font color="2292B5">**1. Regionalisation** </font>

* Clustering
* Dependence of bivariate extremes
* Practicalities
* Classification

<font color="2292B5">**2. Visualise spatial dependence** </font>

* Max-stable processes

<font color="2292B5">**3. Spatial post-processing** </font>


# Clustering

## Clustering Distance

<font color="2292B5">**Form clusters based on extremal dependence!**</font><br/ >
(Bernard et al 2013)

* Use only the raw annual maxima
* No information about climate or topography

## Clustering Distance

<font color="2292B5">**Use the F-madogram distance**</font></br> (Cooley et al 2006)
<font color="2292B5">$$d(x_i, x_j) = \tfrac{1}{2} \mathbb{E} \left[ \left| F_i(M_{x_i}) - F_j(M_{x_j})) \right| \right]$$</font>
where
<font color="2292B5">$M_{x_i}$</font> is the annual maximum rainfall at location
<font color="2292B5">$x_i \in \mathbb{R}^2$</font> and <font color="2292B5">$F_i$</font> is the distribution function of
<font color="2292B5">$M_{x_i}$</font>.

This distance can be estimated non-parametrically.

<div class="notes">
- In spatial statistics normally we have a notion of how close two things are using the variogram
- For heavy-tail distribution (problem) variance isn't finite
- Fmadogram gets aroudn this by using distribution funcitons
- Estiamte this distance non-parametrically
- Just going to consider hte clustering in terms of hte dependence
</div>

## Extremal Coefficient

For <font color="2292B5">$M_{x_i}$</font> and
<font color="2292B5">$M_{x_j}$</font> with common GEV marginals, <font color="2292B5">$\theta(x_i - x_j)$</font> is
<font color="2292B5">$$\mathbb{P}\left( M_{x_i} \leq z, M_{x_j} \leq z \right) = \left[\mathbb{P}(M_{x_i}\leq z)\mathbb{P}(M_{x_i}\leq z)) \right]^{\tfrac{1}{2}\theta(x_i - x_j)}. %= \exp\left(\dfrac{-\theta(h)}{z}\right),$$</font>

The range of <font color="2292B5">$\theta(x_i - x_j)$ is $[1 , 2]$</font>.

Can write our distance measure as a function of the extremal coefficient, <font color="2292B5">$\theta(x_i - x_j)$,
$$d(x_i, x_j) = \dfrac{\theta(x_i - x_j) - 1}{2(\theta(x_i - x_j) + 1)}.$$</font>

Therefore the range of <font color="2292B5">$d(x_i, x_j)$</font> is <font color="2292B5">$[0 , 1/6]$</font>.

<div class="notes">
- Extremal coefficient is a measure for parital dependence
- Using it for clustering, means our clsuters will have a natural interpretation
- Importnat to note the range (talk about that again in a little bit)
</div>

## K-Medoids Clustering

Partitioning around Medoids (PAM):
(Kaufman and Rousseeuw 1990)

1. Randomly select an initial set of $K$ stations. These are the set of the initial medoids.
2. Assign each station, $x_i$, to its closest medoid, $m_k$, based on the F-madogram distance.
3. For each cluster, $C_k$, update the medoid according to
$$m_k = \mathop{\mathrm{argmin}}\limits_{x_i \in C_k} \sum_{x_j \in C_k} d(x_i, x_j).$$
4. Repeat steps 2. -- 4. until the medoids are no longer updated.

## Result

SWWA 
EA

## Assumptions

Truth


## Example

Consider the <font color="2292B5">$\| x_i - x_j \|$</font> as the clustering distance.
```{r, echo = F, warning = F}
set.seed(1)
cap = 2
theta = seq(0, 2*pi, length.out = 360)
circle = data.frame(x = cap*cos(theta), y = cap*sin(theta))

# CAP ON DISTANCE
xshift = 7

x0 = rnorm(500, 0, 1)
y0 = rnorm(500, 0, 1)

x1 = x0 + xshift
y1 = y0

x = c(x0,x1)
y = c(y0,y1)

DD = dist(cbind(x,y))
i = which(DD > cap)
DD[i] = cap

pam_clusters = pam(DD, k = 2)

k = 2
cap_df = data.frame(x,y)
cap_df$K = rep(k, nrow(cap_df))
cap_df$cluster_id = pam_clusters$clustering
cap_df$medoids_x = rep(NA, nrow(cap_df))
cap_df$medoids_y = rep(NA, nrow(cap_df))
cap_df$medoids_x[pam_clusters$medoids] = cap_df$x[pam_clusters$medoids]
cap_df$medoids_y[pam_clusters$medoids] = cap_df$y[pam_clusters$medoids]

kmedoids_eg1_plot <- ggplot() +
  geom_point(data = cap_df, aes(x=x, y=y,
                                col = as.factor(pam_clusters$clustering),
                                shape = as.factor(pam_clusters$clustering),
                                text = paste("Cluster ID:", as.factor(pam_clusters$clustering)))) +
  scale_color_manual(values = c("purple", "orange")) +
  geom_point(data = cap_df, aes(x = medoids_x,
                                y = medoids_y),
             col = "black", shape = 20, size = 2) +
  geom_path(aes(x = circle$x, y = circle$y), linetype = "dashed") +
  geom_path(aes(x = circle$x + xshift, y = circle$y), linetype = "dashed") +
  coord_fixed() +
  theme_bw() +
  theme(legend.position = "none") +
  ggtitle("Example of K-Medoids showing spurious clustering")

ggplotly(kmedoids_eg1_plot, tooltip = c("text"))

```

## Density example

```{r, echo = F, warning = F}

xshift = 7
x0 = rnorm(1000, 0, 1)
y0 = rnorm(1000, 0, 1)

i = sample(1:length(x0), 100)
x1 = x0[i] + xshift
y1 = y0[i]

x = c(x0,x1)
y = c(y0,y1)

cap = 2
DD = dist(cbind(x,y))
i = which(DD > cap)
DD[i] = cap

pam_clusters_1 = pam(DD, k = 2)

plot_df = data.frame(x,y)
plot_df$K = paste("K = ", c(rep(2, length(x))))
plot_df$cluster_id = c(pam_clusters_1$clustering)
plot_df$medoids_x = rep(NA, nrow(plot_df))
plot_df$medoids_y = rep(NA, nrow(plot_df))
plot_df$medoids_x[pam_clusters_1$medoids] = plot_df$x[pam_clusters_1$medoids]
plot_df$medoids_y[pam_clusters_1$medoids] = plot_df$y[pam_clusters_1$medoids]

density_eg_plot <- ggplot(plot_df) +
  geom_point(aes(x = x, y = y,
                 col = as.factor(cluster_id),
                 shape = as.factor(cluster_id),
                 text = paste("Cluster ID:", as.factor(cluster_id)))) +
  geom_point(aes(x = medoids_x,
                 y = medoids_y),
             col = "black", shape = 20, size = 2) +
  coord_fixed() +
  theme_bw() +
  facet_wrap( ~ K, nrow = 2) +
  theme(legend.position = "none") +
  ggtitle("Station Density Example of K-Medoids")

ggplotly(density_eg_plot, tooltip = c("text"))

```

## Back to our example

## Gridded data

## Hierarchical Clustering

1. Each station starts in its own cluster
2. For each pair of clusters, <font color="2292B5">$C_k$</font> and <font color="2292B5">$C_k'$</font>, define the distance between the clusters as
<font color="2292B5">$$d(C_k, C_{k'}) = \frac{1}{|C_k| |C_{k'}|} \sum_{x_k \in C_k} \sum_{x_{k'} \in C_{k'}} d(x_k, x_{k'}).$$</font>
3. Merge the the clusters with the smallest distance
4. Update the distances relative to the new cluster
5. Repaet steps 3 - 5, until all points are combined in a single cluster

## Hierarchical Clustering

<font color="2292B5">$$d(C_k, C_{k'}) = \frac{1}{|C_k| |C_{k'}|} \sum_{x_k \in C_k} \sum_{x_{k'} \in C_{k'}} d(x_k, x_{k'}).$$</font>

PICTURE
<!-- <center> -->
<!-- <img src= "kate_img/TAS_linkage_average.png" width = 65%> -->
<!-- </center> -->


## Classify

* Classify a station relative to its closest neighbours
* Use a weighted classification $w$-kNN

IMAGE
<!-- <center> -->
<!-- <img src= "kate_img/classification.png" width = 65%> -->

<div class="notes">
* Need to be able to classify locations without a station
* Need to be able to identify regional boundaries
</div>

## Results

SHINY APP

<!-- ```{r regions, echo = FALSE} -->
<!-- shinyAppDir("shiny_apps/region_summary/", -->
<!--  options = list(width = "100%", height = 700) -->
<!-- ) -->
<!-- ``` -->

## Choosing a cut height

IMAGE
<!-- <center> -->
<!-- <img src= "kate_img/missing_fmado.png" width = 100%> -->
<!-- </center> -->

<div class="notes">
Depends on what you are trying to do?

Lower cut heights ~0.115 stronger dependence

Higher cut heights ~0.133 weaer dependence

Low than 0.1 (very strong dependence, starts to decrease rapidly to zero - clusters become small)

Greater than 0.135 (very week depdence, starts to decrease rapidly to zero - clusters become small)

Depends on the topography as well
</div>

## Similar Dependence

<font color="2292B5"> **Where can we assume a common dependence structure for extremes?** </font >

# Max-stable processes

## Max-stable process

Shiny App

## Level curves

## Visualising Dependence

SWWA 

TAS
 
## Relevance to post-processing
 
Oesting et. al 2017

* approach

* cut the region into two
 
# Conclusions

## Conclusions




